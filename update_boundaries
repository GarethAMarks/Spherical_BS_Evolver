//updates the outermost two boundary points using radiation BC. Must be called at end of time loop in evolve()!
void Spacetime::update_outer_boundary(double time_step)
{
    //temporary vars for outermost 2 gripoints
    BSSNState outer_state_temp =  slices[time_step].states[n_gridpoints - 1];
    BSSNState outer_state2_temp =  slices[time_step].states[n_gridpoints - 2];
    BSSNState outer_state3_temp =  slices[time_step].states[n_gridpoints - 3];

    //third-from-innermost state, which should already be updated by standard RK4.
    BSSNState outer3_state = slices[time_step + 1].states[n_gridpoints - 3];

    //radius to average position between 2nd- and 3rd-to-outermost gridpoints and 1st- and 2nd-to outermost gridpoints
    double r2 = dr * ( n_gridpoints - 2.5);
    double r1 = dr * ( n_gridpoints - 1.5);

    //initialize pre_outer_state values on first timestep
    if (time_step == 0)
        {
            prev_outer_state = slices[0].states[n_gridpoints - 1];
            prev_outer2_state = slices[0].states[n_gridpoints - 2];
            prev_outer3_state = slices[0].states[n_gridpoints - 2];
        }

    //limiting BSSN state at infinity: lapse, chi, h_zz,h_ww go to infinity, others to 0
    BSSNState asymp_state{1., 1., 1., 0., 0., 0., 0., 0., 0., 0., 0., 1., 0.,};

    //update 2nd-to-outermost then outermost gridpoint using outgoing wave BC with 2nd-order-accurate midpoint-based time and space differencing
    //NOTE: may need to modify for beta (maybe alpha + matter vars?) to account for non-lightspeed characteristic speeds
    slices[time_step + 1].states[n_gridpoints - 2] = (1. / (1 + courant_factor + 0.5 * r2)) * ((-1 + courant_factor - 0.5 * dt / r2) * outer3_state + (1 + courant_factor + 0.5 * dt / r2) * prev_outer3_state + (1 - courant_factor - 0.5 * dt / r2) * prev_outer2_state) ;
    slices[time_step + 1].states[n_gridpoints - 1] = (1. / (1 + courant_factor + 0.5 * r1)) * ((-1 + courant_factor - 0.5 * dt / r1) * slices[time_step + 1].states[n_gridpoints - 2] + (1 + courant_factor + 0.5 * dt / r1) * prev_outer2_state + (1 - courant_factor - 0.5 * dt / r1) * prev_outer_state);

    if (time_step != 0)
    {
        prev_outer_state = slices[time_step + 1].states[n_gridpoints - 1];
        prev_outer2_state = slices[time_step + 1].states[n_gridpoints - 2];
        prev_outer3_state = slices[time_step + 1].states[n_gridpoints - 3];
    }

    cout << slices[time_step + 1].states[n_gridpoints - 1].chi << endl;
}
